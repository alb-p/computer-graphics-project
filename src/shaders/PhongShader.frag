#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragTexCoord;layout(location = 0) out vec4 outColor;layout(binding = 0) uniform UniformBufferObject {	mat4 mvpMat;	mat4 mMat;	mat4 nMat;	vec4 color;} ubo;layout(binding = 1) uniform sampler2D texSampler;layout(binding = 2) uniform GlobalUniformBufferObject {	vec3 lightDir[5];	vec3 lightPos[5];	vec4 lightColor[5];	float cosIn;	float cosOut;	vec3 eyePos;	vec4 eyeDir;	vec4 lightOn;    int lightType;	} gubo;		vec3 direct_light_dir(vec3 pos, int i) {	// Direct light - direction vector	// Direction of the light in <gubo.lightDir[i]>	return normalize(gubo.lightDir[i]);}vec3 direct_light_color(vec3 pos, int i) {	return gubo.lightColor[i].rgb;}vec3 point_light_dir(vec3 pos, int i) {	return normalize(gubo.lightPos[i]-pos);}vec3 point_light_color(vec3 pos, int i) {     vec3 lightColor = gubo.lightColor[i].rgb;    float lightScalingFactor = gubo.lightColor[i].a;    vec3 lightPosition = gubo.lightPos[i];    float beta = 2.0; // Decay power            // Calculate the vector from the light to the fragment    vec3 toLight = lightPosition - pos;    float distance = length(toLight);                    vec3 finalColor = pow((gubo.lightColor[i].a/distance),beta)*gubo.lightColor[i].rgb;            return finalColor;}vec3 BRDF(vec3 Albedo, vec3 Norm, vec3 EyeDir, vec3 LD) {	vec3 Diffuse;	vec3 Specular;	Diffuse = Albedo * max(dot(Norm, LD),0.0f);	Specular = vec3(pow(max(dot(EyeDir, -reflect(LD, Norm)),0.0f), 160.0f));		return Diffuse + Specular;}void main() {	vec3 Norm = normalize(fragNorm);	vec3 EyeDir = normalize(gubo.eyePos - fragPos);	vec3 Albedo = texture(texSampler, fragTexCoord).rgb;	vec3 LD;	// light direction	vec3 LC;	// light color	vec3 RendEqSol = vec3(0);        if (gubo.lightType == 0) {        LD = direct_light_dir(fragPos, 0);        LC = direct_light_color(fragPos, 0);        RendEqSol += BRDF(Albedo, Norm, EyeDir, LD) * LC         * gubo.lightOn.y;    }        else {                        LD = point_light_dir(fragPos, 1);        LC = point_light_color(fragPos, 1);        RendEqSol += BRDF(Albedo, Norm, EyeDir, LD) * LC         * gubo.lightOn.x;                        LD = point_light_dir(fragPos, 2);        LC = point_light_color(fragPos, 2);        RendEqSol += BRDF(Albedo, Norm, EyeDir, LD) * LC         * gubo.lightOn.x;                        LD = point_light_dir(fragPos, 3);        LC = point_light_color(fragPos, 3);        RendEqSol += BRDF(Albedo, Norm, EyeDir, LD) * LC         * gubo.lightOn.x;                        LD = point_light_dir(fragPos, 4);        LC = point_light_color(fragPos, 4);        RendEqSol += BRDF(Albedo, Norm, EyeDir, LD) * LC         * gubo.lightOn.x;    }    	const vec3 cxp = vec3(1.0,0.5,0.5) * 0.2;	const vec3 cxn = vec3(0.9,0.6,0.4) * 0.2;	const vec3 cyp = vec3(0.3,1.0,1.0) * 0.2;	const vec3 cyn = vec3(0.5,0.5,0.5) * 0.2;	const vec3 czp = vec3(0.8,0.2,0.4) * 0.2;	const vec3 czn = vec3(0.3,0.6,0.7) * 0.2;		vec3 Ambient =((Norm.x > 0 ? cxp : cxn) * (Norm.x * Norm.x) +				   (Norm.y > 0 ? cyp : cyn) * (Norm.y * Norm.y) +				   (Norm.z > 0 ? czp : czn) * (Norm.z * Norm.z)) * Albedo;	RendEqSol += Ambient         * gubo.lightOn.w;			outColor = vec4(RendEqSol, 1.0f);}